# Executa o pipeline em todo commit na branch main
trigger:
- main

# Usa o agent pool self hosted e força um agente específico
pool:
  name: agentPoolPucMinas
  demands:
    - Agent.Name -equals mac-agent-pucminas-01

# Variáveis globais do pipeline
variables:
  # Lista de regiões candidatas em ordem de prioridade
  # Removido brazilseast pois não é região válida para Resource Group na sua assinatura
  candidateLocations: 'brazilsouth eastus2 eastus southcentralus westus2 westus3 centralus'

  # Lista de SKUs candidatas para tentar alocação de VM
  # Inclui opções menores para aumentar chance em assinaturas com restrições e capacidade limitada
  vmSkuFallbacks: 'Standard_B1s Standard_B1ms Standard_B2s Standard_B2ms Standard_D2s_v3 Standard_D2as_v5 Standard_DS1_v2'

  # Nome base da VM que será criada pelo template ARM
  vmName: 'vm-iac-web-iis'

  # Script PowerShell hospedado no GitHub para ser executado dentro da VM Windows via Custom Script Extension
  scriptUrl: 'https://raw.githubusercontent.com/lmlpuc/lmlarm003/refs/heads/main/src/scripts/site.ps1'

stages:
# =========================
# STAGE 1, Infraestrutura
# =========================
- stage: DeployInfra
  displayName: 'Provisionar Infraestrutura'
  jobs:
  - job: Deploy
    displayName: 'Criar RG e recursos ARM'
    steps:

    # ---------------------------------------------------------
    # Step 1: Seleciona região e SKU com base em validação real do ARM
    # Objetivo: evitar falso positivo de disponibilidade, pois Capacity Restrictions
    # pode aparecer apenas na validação ou no deploy, mesmo quando list-skus não acusa.
    # ---------------------------------------------------------
    - task: AzureCLI@2
      displayName: 'Selecionar região e SKU com validação real do ARM'
      inputs:
        azureSubscription: 'ar01com'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e

          echo "Regiões candidatas: $(candidateLocations)"
          echo "SKUs candidatas: $(vmSkuFallbacks)"

          # Caminhos do template e parâmetros dentro do repositório
          templateFile="arm-templates/vm-iis-template.json"
          paramsFile="arm-templates/vm-iis-parameters.json"

          # Variáveis para armazenar a escolha final
          chosenLoc=""
          chosenSku=""
          chosenRg=""

          # Lista de regiões válidas para esta assinatura, evita erro ao tentar criar RG em região inválida
          validLocations=$(az account list-locations --query "[].name" -o tsv)

          is_valid_location () {
            echo "$validLocations" | tr '\t' '\n' | grep -qx "$1"
          }

          # Loop por região
          for loc in $(candidateLocations); do

            # Se a região não existir para esta assinatura, pula
            if ! is_valid_location "$loc"; then
              echo "Região inválida para esta assinatura: $loc, pulando."
              continue
            fi

            # Nome do RG derivado da região para evitar conflito de localizações
            rg="rg-iac-web-iis-$loc"
            echo "Testando região: $loc, RG: $rg"

            # Garante que o RG exista na região correta
            if az group show --name "$rg" >/dev/null 2>&1; then
              rgLoc=$(az group show --name "$rg" --query location -o tsv)
              echo "RG já existe em: $rgLoc"

              # Se o RG existir em outra região, não dá para usar, então pula
              if [ "$rgLoc" != "$loc" ]; then
                echo "RG $rg existe em $rgLoc, região testada é $loc, pulando esta região."
                continue
              fi
            else
              # Cria RG e, se falhar, não aborta o pipeline inteiro, apenas tenta próxima região
              set +e
              az group create --name "$rg" --location "$loc" >/dev/null 2>&1
              rc=$?
              set -e

              if [ $rc -ne 0 ]; then
                echo "Falha ao criar RG em $loc, pulando para próxima região."
                continue
              fi
            fi

            # Loop por SKU, validando o template com overrideParameters
            for sku in $(vmSkuFallbacks); do
              echo "Validando template em $loc com SKU $sku"

              # validate real, se passar aqui, a chance de falhar por capacidade cai bastante
              set +e
              az deployment group validate \
                --resource-group "$rg" \
                --template-file "$templateFile" \
                --parameters "@$paramsFile" \
                --parameters vmSku="$sku" vmName="$(vmName)" location="$loc" \
                1>/dev/null 2>/dev/null
              rc=$?
              set -e

              # Se a validação passou, escolhe esta combinação
              if [ $rc -eq 0 ]; then
                chosenLoc="$loc"
                chosenSku="$sku"
                chosenRg="$rg"
                echo "Validação OK, escolhidos: location=$chosenLoc, sku=$chosenSku, rg=$chosenRg"
                break
              else
                echo "Validação falhou para $loc com $sku, tentando próxima SKU."
              fi
            done

            # Se já escolheu, sai do loop de regiões
            if [ -n "$chosenLoc" ]; then
              break
            fi
          done

          # Se não encontrou combinação válida, falha o pipeline
          if [ -z "$chosenLoc" ] || [ -z "$chosenSku" ] || [ -z "$chosenRg" ]; then
            echo "Nenhuma combinação válida de região e SKU foi encontrada."
            exit 1
          fi

          # Exporta variáveis para os próximos steps do pipeline
          echo "##vso[task.setvariable variable=locationChosen]$chosenLoc"
          echo "##vso[task.setvariable variable=vmSkuChosen]$chosenSku"
          echo "##vso[task.setvariable variable=resourceGroupNameChosen]$chosenRg"

    # ---------------------------------------------------------
    # Step 2: Executa o deploy do ARM Template
    # Usa as variáveis escolhidas no step anterior para evitar falhas por capacidade e região
    # ---------------------------------------------------------
    - task: AzureResourceManagerTemplateDeployment@3
      displayName: 'Deploy ARM Template'
      inputs:
        deploymentScope: 'Resource Group'
        azureResourceManagerConnection: 'ar01com'
        action: 'Create Or Update Resource Group'
        resourceGroupName: '$(resourceGroupNameChosen)'
        location: '$(locationChosen)'
        templateLocation: 'Linked artifact'
        csmFile: 'arm-templates/vm-iis-template.json'
        csmParametersFile: 'arm-templates/vm-iis-parameters.json'

        # Sobrescreve parâmetros críticos
        overrideParameters: >
          -vmSku "$(vmSkuChosen)"
          -vmName "$(vmName)"
          -location "$(locationChosen)"

        deploymentMode: 'Incremental'
        deploymentName: 'vm-iis-deployment'

# =========================
# STAGE 2, Configuração IIS
# =========================
- stage: ConfigureWebsite
  displayName: 'Publicar site no IIS'
  dependsOn: DeployInfra

  # Só executa se o deploy de infraestrutura tiver sucesso
  condition: succeeded()
  jobs:
  - job: PublishHTML
    displayName: 'Executar CustomScriptExtension para copiar index.html'
    steps:

    # ---------------------------------------------------------
    # Executa uma extensão na VM para rodar o script PowerShell
    # O script deve estar acessível publicamente na URL informada
    # ---------------------------------------------------------
    - task: AzureCLI@2
      displayName: 'Executar CustomScriptExtension'
      inputs:
        azureSubscription: 'ar01com'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          # Gera o JSON de settings da extensão
          cat <<EOF > customScriptSettings.json
          {
            "fileUris": [
              "$(scriptUrl)"
            ],
            "commandToExecute": "powershell -ExecutionPolicy Bypass -File site.ps1"
          }
          EOF

          # Aplica a extensão na VM no RG selecionado dinamicamente
          az vm extension set \
            --resource-group "$(resourceGroupNameChosen)" \
            --vm-name "$(vmName)" \
            --name CustomScriptExtension \
            --publisher Microsoft.Compute \
            --settings customScriptSettings.json